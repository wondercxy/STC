package com.cxy.model;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.math.*;
import Jama.*;

public class TRM {

	public class pair {
		public int a, b;

		public pair(int a, int b) {
			this.a = a;
			this.b = b;
		}

		public pair() {
		}
	}

	public HashMap<Integer, HashSet<Integer>> usercheckinset;
	public HashMap<Integer, Point> home_location;
	public HashMap<Integer, Point> location_map;

	public int V; // Vocabulary Size (Item size)
	public int K1; // The number of topics
	public int K2;// The number of user activity areas
	public int U; // The number of Users
	// public int M; //The number of item locations
	// public int C;//The number of item category

	// Dirichlet parameter (user--topic associations)
	public double alpha[];
	public double alpha_sum;

	// Dirichlet parameter (user--activity area associations)
	public double alpha_2[];
	public double alpha_2_sum;

	// Dirichlet parameter (topic--item associations)
	public double beta[];
	public double beta_sum;

	// Beta parameter (affect s = 0 or s = 1)
	// public double gamma[];
	// public double gamma_sum;

	// [u][0]: number of times s = 0 has been sampled in user u's D_u
	// [u][1]: ...
	// public int[][] userSCount;

	// [u][z]: number of times that topic z has been sampled from
	// the multinomial distribution specific to user u;
	public int[][] userTopicCount;
	// [u] :
	public int[] userTopicCountSum;

	// [u][x] : number of times that area x has been
	// sampled from the multinomial distribution specific to user u;
	public int[][] userAreaCount;
	// [u]
	public int[] userAreaCountSum;
	public int[] topic_Count;
	public int[] region_Count;

	public double[] topic_Popularity;
	public double[] region_Popularity;
	// [z][v] : number of times item v has been generated by topic z
	public int[][] topicItemCount;
	public int[] topicItemCountSum;

	public int[][] areaItemCount;
	public int[] areaItemCountSum;

	// Gaussian parameters (latent area--location associations)
	public Point mu[];
	public double covariance[][];

	// [u][z]: user - topic
	public double[][] userTopicDistribution;
	// [l][z]: loc - topic
	public double[][] userAreaDistribution;
	// [z][v]: topic - word
	public double[][] topicItemDistribution;

	public double[][] areaItemDistribution;

	// s = 1 : user
	// public double[] lambda_u;

	// [i][j]: user - topic
	public double[][] userTopicSum;
	// [i][j]: time - topic
	public double[][] userAreaSum;
	// [i][j]: topic - word
	public double[][] topicItemSum;

	public double[][] areaItemSum;

	public double muSum[][];
	public double covarianceSum[][];

	// public double[] lambda_uSum;

	// test lambda_u
	// private double[] lambda_uSum_test;
	// private int lambdaNum_test;

	// public int AreaItemCountSum;
	// [i][j]: user - topic
	public int userTopicNum;
	// [i][j]: time - topic
	public int userAreaNum;
	// [i][j]: topic - word
	public int topicItemNum;

	public int areaItemNum;
	// [i][j]: topic - loc
	// public int topicLocationNum;
	//
	// public int lambdaNum;

	public int ITERATIONS;
	public int SAMPLE_LAG;
	public int BURN_IN;
	public String outputPath;

	public HashMap<Integer, UserProfile> user_item;

	// test
	public int iter = 0;

	public TRM(String check_in_file, int K1, int K2, double[] alpha, double[] alpha_2, double[] beta, int U, int V,
			String matrixPath) {
		load_data(check_in_file);
		this.K1 = K1;
		this.K2 = K2;
		this.V = V;
		this.U = U;
		this.alpha = alpha;
		this.alpha_2 = alpha_2;
		this.beta = beta;
		userTopicDistribution = new double[U][K1];
		userAreaDistribution = new double[U][K2];
		topicItemDistribution = new double[K1][V];
		areaItemDistribution = new double[K2][V];
		this.topic_Popularity = new double[K1];
		this.region_Popularity = new double[K2];
		mu = new Point[K2];
		covariance = new double[K2][2];

		loadJoint_LALDA(matrixPath);
		user_item = null;

	}

	public void loadJoint_LALDA(String path) {

		BufferedReader reader;
		try {

			reader = new BufferedReader(new InputStreamReader(new FileInputStream(path + "userTopic.txt"), "UTF-8"));
			String line = reader.readLine();
			String[] tokens = line.split(" ");
			int num_of_users = Integer.parseInt(tokens[0]);
			int num_of_topics = Integer.parseInt(tokens[1]);
			line = reader.readLine();
			int u_id = 0;
			while (line != null) {
				tokens = line.split(" ");

				for (int i = 0; i < tokens.length; i++) {
					double value = Double.parseDouble(tokens[i]);
					this.userTopicDistribution[u_id][i] = value;
				}

				line = reader.readLine();
				u_id++;
			}
			reader.close();
			System.out.println("userTopicDistribution is loaded");

			reader = new BufferedReader(new InputStreamReader(new FileInputStream(path + "userArea.txt"), "UTF-8"));
			line = reader.readLine();
			tokens = line.split(" ");
			num_of_users = Integer.parseInt(tokens[0]);
			int num_of_regions = Integer.parseInt(tokens[1]);
			line = reader.readLine();
			u_id = 0;
			while (line != null) {
				tokens = line.split(" ");

				for (int i = 0; i < tokens.length; i++) {
					double value = Double.parseDouble(tokens[i]);
					this.userAreaDistribution[u_id][i] = value;
				}

				line = reader.readLine();
				u_id++;
			}
			reader.close();
			System.out.println("userAreaDistribution is loaded");

			reader = new BufferedReader(new InputStreamReader(new FileInputStream(path + "topicItem.txt"), "UTF-8"));
			line = reader.readLine();
			tokens = line.split(" ");
			num_of_topics = Integer.parseInt(tokens[0]);
			int num_of_items = Integer.parseInt(tokens[1]);
			line = reader.readLine();
			int topic_id = 0;
			while (line != null) {
				tokens = line.split(" ");

				for (int i = 0; i < tokens.length; i++) {
					double value = Double.parseDouble(tokens[i]);
					this.topicItemDistribution[topic_id][i] = value;
				}

				line = reader.readLine();
				topic_id++;
			}
			reader.close();
			System.out.println("topicItemDistribution is loaded");

			reader = new BufferedReader(new InputStreamReader(new FileInputStream(path + "AreaItem.txt"), "UTF-8"));
			line = reader.readLine();
			tokens = line.split(" ");
			num_of_regions = Integer.parseInt(tokens[0]);
			num_of_items = Integer.parseInt(tokens[1]);
			line = reader.readLine();
			topic_id = 0;
			while (line != null) {
				tokens = line.split(" ");

				for (int i = 0; i < tokens.length; i++) {
					double value = Double.parseDouble(tokens[i]);
					this.areaItemDistribution[topic_id][i] = value;
				}

				line = reader.readLine();
				topic_id++;
			}
			reader.close();
			System.out.println("areaItemDistribution is loaded");

			reader = new BufferedReader(new InputStreamReader(new FileInputStream(path + "mu.txt"), "UTF-8"));
			line = reader.readLine();
			num_of_regions = Integer.parseInt(line);
			line = reader.readLine();
			if (line != null) {
				tokens = line.split(" ");
				for (int i = 0; i < tokens.length; i++) {

					if (tokens[i].equals("")) {

					} else {
						String[] tk = tokens[i].split(":");
						double x = Double.parseDouble(tk[0]);
						double y = Double.parseDouble(tk[1]);
						Point p = new Point();
						p.x = x;
						p.y = y;
						this.mu[i] = p;

					}
				}
			}
			reader.close();
			System.out.println("mu is loaded");

			reader = new BufferedReader(
					new InputStreamReader(new FileInputStream(path + "topicPopularity.txt"), "UTF-8"));
			line = reader.readLine();
			num_of_topics = Integer.parseInt(line);
			line = reader.readLine();
			if (line != null) {

				tokens = line.split(" ");
				for (int i = 0; i < tokens.length; i++) {
					double value = Double.parseDouble(tokens[i]);
					this.topic_Popularity[i] = value;
				}
			}
			reader.close();
			System.out.println("Topic Popuparity is loaded");

			reader = new BufferedReader(
					new InputStreamReader(new FileInputStream(path + "regionPopularity.txt"), "UTF-8"));
			line = reader.readLine();
			num_of_regions = Integer.parseInt(line);
			line = reader.readLine();
			if (line != null) {

				tokens = line.split(" ");
				for (int i = 0; i < tokens.length; i++) {
					double value = Double.parseDouble(tokens[i]);
					this.region_Popularity[i] = value;
				}
			}
			reader.close();
			System.out.println("Region Popuparity is loaded");

			reader = new BufferedReader(new InputStreamReader(new FileInputStream(path + "covariance.txt"), "UTF-8"));
			line = reader.readLine();
			num_of_regions = Integer.parseInt(line);
			line = reader.readLine();
			if (line != null) {
				tokens = line.split(" ");
				for (int i = 0; i < tokens.length; i++) {

					if (tokens[i].equals("")) {

					} else {
						String[] tk = tokens[i].split(":");
						double x = Double.parseDouble(tk[0]);
						double y = Double.parseDouble(tk[1]);
						this.covariance[i][0] = x;
						this.covariance[i][1] = y;

					}
				}
			}
			reader.close();
			System.out.println("covariance is loaded");

		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	public TRM(String check_in_file, int K1, int K2, double[] alpha, double[] alpha_2, int iterations, int sampleLag,
			int burnIn, int U, int V, String outputPath) {
		load_data(check_in_file);
		this.K1 = K1;
		this.K2 = K2;
		this.V = V;
		this.U = U;

		this.ITERATIONS = iterations;
		this.SAMPLE_LAG = sampleLag;
		this.BURN_IN = burnIn;
		this.outputPath = outputPath;

		this.alpha = alpha;
		this.alpha_2 = alpha_2;

		// this.gamma = gamma;

		// userSCount = new int[U][2];
		userTopicCount = new int[U][K1];
		userAreaCount = new int[U][K2];

		topicItemCount = new int[K1][V];
		topicItemCountSum = new int[K1];

		this.topic_Popularity = new double[K1];
		this.region_Popularity = new double[K2];
		
		this.topic_Count = new int[K1];
		this.region_Count = new int[K2];

		areaItemCount = new int[K2][V];
		areaItemCountSum = new int[K2];

		userTopicDistribution = new double[U][K1];
		userAreaDistribution = new double[U][K2];
		topicItemDistribution = new double[K1][V];
		areaItemDistribution = new double[K2][V];

		mu = new Point[K2];
		covariance = new double[K2][2];
		// topicCategoryDistribution = new double[K][C];
		// lambda_u = new double[U];

		userTopicSum = new double[U][K1];
		userAreaSum = new double[U][K2];
		topicItemSum = new double[K1][V];
		areaItemSum = new double[K2][V];

		muSum = new double[K2][2];
		covarianceSum = new double[K2][2];

		// lambda_uSum = new double[U];

		userTopicCountSum = new int[U];
		userAreaCountSum = new int[U];

		// topicCategoryCount = new int[K][C];
		// topicCategoryCountSum = new int[K];

		alpha_sum = 0;
		alpha_2_sum = 0;
		// gamma_sum = 0;
		beta_sum = 0;

		this.beta = new double[V];
		for (int i = 0; i < V; i++) {

			this.beta[i] = 0.01;

		}

	}

	public static void main(String args[]) {
		String dir = "/home/hyin/dataset/Gowalla/";
		String checkinfile = dir + "Gowalla_trainoutoftown.txt";
		int K1 = 50;
		int K2 = 50;
		int iterations = 1000;
		String outputPath = "/home/hyin/LSA_Experiments_Biased/Joint_LALDA/";

		double[] alpha = new double[K1];
		double[] alpha2 = new double[K2];
		for (int i = 0; i < K1; i++) {
			alpha[i] = 50.0 / K1;

		}

		for (int i = 0; i < K2; i++) {
			alpha2[i] = 50.0 / K2;

		}

		double[] gamma = new double[2];
		gamma[0] = 0.5;
		gamma[1] = 0.5;

		int burnIn = 300;
		int sampleLag = 10;

		int U = 107092;
		int V = 1280969;

		TRM la = new TRM(checkinfile, K1, K2, alpha, alpha2, iterations, sampleLag, burnIn, U, V, outputPath);
		la.train();

	}

	public void train() {
		initialState();

		gibbsSampling();

		calDistribution();

		output_model();
	}

	public void initialState() {

		// z-x pair
		for (int i = 0; i < U; i++) {
			int length = user_item.get(i).items.size();//用户i中不同locationid的数量

			for (int j = 0; j < length; j++) {

				int ran = (int) (Math.random() * K2);

				user_item.get(i).setX(j, ran);
				userAreaCount[i][ran]++;
				userAreaCountSum[i]++;

				areaItemCount[ran][user_item.get(i).getItem(j)]++;
				areaItemCountSum[ran]++;

				ran = (int) (Math.random() * K1);
				user_item.get(i).setZ(j, ran);
				topicItemCount[ran][user_item.get(i).getItem(j)]++;
				topicItemCountSum[ran]++;

				userTopicCount[i][ran]++;
				userTopicCountSum[i]++;

			}
		}

		for (int i = 0; i < K1; i++) {
			alpha_sum += alpha[i];

		}

		for (int i = 0; i < K2; i++) {
			alpha_2_sum += alpha_2[i];

		}
		for (int i = 0; i < V; i++) {
			beta_sum += beta[i];
		}

		// gamma_sum = gamma[0] + gamma[1];

		for (int i = 0; i < areaItemCount.length; i++) {

			Point u = new Point();
			double[] covariance = new double[2];
			for (int j = 0; j < areaItemCount[i].length; j++) {
				if (areaItemCount[i][j] > 0) {
					u.x += areaItemCount[i][j] * location_map.get(j).x;
					u.y += areaItemCount[i][j] * location_map.get(j).y;

				}

			}

			u.x = u.x / areaItemCountSum[i];
			u.y = u.y / areaItemCountSum[i];

			mu[i] = u;

			System.out.println("Innitilzied mu " + i + ":" + u.x + "," + u.y);

			for (int j = 0; j < areaItemCount[i].length; j++) {
				if (areaItemCount[i][j] > 0) {
					covariance[0] += (areaItemCount[i][j]) * (location_map.get(j).getX() - u.x)
							* (location_map.get(j).getX() - u.x);
					covariance[1] += (areaItemCount[i][j]) * (location_map.get(j).getY() - u.y)
							* (location_map.get(j).getY() - u.y);
					// covariance[0][1]+=(areaItemCount[i][j])*(location_map.get(j).getX()-u.x)*(location_map.get(j).getY()-u.y);
				}

			}

			covariance[0] /= areaItemCountSum[i];
			covariance[1] /= areaItemCountSum[i];

			this.covariance[i] = covariance;

			System.out.println("covariance " + i + ":" + this.covariance[i][0] + ":" + this.covariance[i][1]);

		}

	}

	public void gibbsSampling() {

		for (int it = 1; it <= this.ITERATIONS; it++) {
			iter = it;

			// System.out.println(covariance[0][0]+" "+covariance[0][1]);

			for (int x = 0; x < areaItemDistribution.length; x++) {

				double sum = 0;

				double temp[] = new double[V];
				// Matrix co=new Matrix(this.covariance[z]);
				// Matrix inverse_matrix=co.inverse();
				// Matrix_Operation.getN(this.covariance[z]);
				for (int k = 0; k < V; k++) {
					if (location_map.containsKey(k)) {
						temp[k] = GaussianProbability(location_map.get(k), x);
						sum += temp[k];
					}

				}

				for (int k = 0; k < V; k++) {

					areaItemDistribution[x][k] = temp[k] / sum;

				}

			}

			// break;
			// System.exit(0);

			System.out.println("Iteration:" + it);
			for (int i = 0; i < U; i++) {
				int length = user_item.get(i).items.size();
				// user i's item j
				for (int j = 0; j < length; j++) {
					pair p = sample(i, j);
					int new_z = p.a;
					user_item.get(i).setZ(j, new_z);
					int new_x = p.b;
					user_item.get(i).setX(j, new_x);

					// System.out.println("state:"+new_s+", topic:"+new_z);
					// System.exit(0);

				}

			}

			// after each iteration, updating Gaussian Parameters
			for (int i = 0; i < areaItemCount.length; i++) {

				Point u = new Point();
				double[] covariance = new double[2];
				for (int j = 0; j < areaItemCount[i].length; j++) {
					if (areaItemCount[i][j] > 0) {
						u.x += areaItemCount[i][j] * location_map.get(j).x;
						u.y += areaItemCount[i][j] * location_map.get(j).y;

					}

				}

				u.x = u.x / areaItemCountSum[i];
				u.y = u.y / areaItemCountSum[i];

				this.mu[i] = u;

				for (int j = 0; j < areaItemCount[i].length; j++) {
					if (areaItemCount[i][j] > 0) {
						covariance[0] += areaItemCount[i][j] * (location_map.get(j).getX() - u.x)
								* (location_map.get(j).getX() - u.x);
						covariance[1] += areaItemCount[i][j] * (location_map.get(j).getY() - u.y)
								* (location_map.get(j).getY() - u.y);
						// covariance[0][1]+=areaItemCount[i][j]*(location_map.get(j).getX()-u.x)*(location_map.get(j).getY()-u.y);

					}

				}

				covariance[0] /= areaItemCountSum[i];
				covariance[1] /= areaItemCountSum[i];

				this.covariance[i] = covariance;
				System.out.println("Area " + i + ":" + u.x + "," + u.y);
				System.out.println("Variance " + i + ":" + covariance[0] + "," + covariance[1]);

			}

			// get statistics after burn-in
			if ((it >= BURN_IN) && (it % SAMPLE_LAG == 0)) {
				this.updateParameter();

				if (it % 200 == 0) {
					calDistribution();
					output_model(it);
					// System.exit(0);
				}
			}

			System.out.println("iteration " + it + " done");
			// testLambdaU();
		}
	}

	public pair sample(int i, int j) {
		pair p = new pair();
		UserProfile user = user_item.get(i);

		int topic = user.getZ(j);
		int region = user.getX(j);

		// int s = user.getS(j);
		int item = user.getItem(j);

		// userSCount[i][s]--;

		userAreaCount[i][region]--;
		userAreaCountSum[i]--;
		areaItemCount[region][item]--;
		areaItemCountSum[region]--;

		userTopicCount[i][topic]--;
		userTopicCountSum[i]--;
		topicItemCount[topic][item]--;
		topicItemCountSum[topic]--;

		double probability[][] = new double[K1][K2];

		for (int z = 0; z < K1; z++)
			for (int x = 0; x < K2; x++) {

				double first_term, second_term, third_term, fourth_term;

				first_term = (userTopicCount[i][z] + alpha[z]) / (userTopicCountSum[i] + alpha_sum);
				second_term = (userAreaCount[i][x] + alpha_2[x]) / (userAreaCountSum[i] + alpha_2_sum);
				third_term = (topicItemCount[z][item] + beta[item]) / (topicItemCountSum[z] + beta_sum);
				fourth_term = areaItemDistribution[x][item];

				probability[z][x] = first_term * second_term * third_term * fourth_term;

			}

		double temp = 0;
		for (int z = 0; z < K1; z++)
			for (int x = 0; x < K2; x++) {
				probability[z][x] = temp + probability[z][x];
				temp = probability[z][x];
			}

		double t = Math.random() * temp;

		for (int z = 0; z < K1; z++)
			for (int x = 0; x < K2; x++) {
				if (t < probability[z][x]) {

					p.a = z;
					p.b = x;
					break;
				}

			}

		if (p.a < 0 || p.b < 0) {
			System.out.println("sampling error");
		}

		userAreaCount[i][p.b]++;
		userAreaCountSum[i]++;
		areaItemCount[p.b][item]++;
		areaItemCountSum[p.b]++;

		userTopicCount[i][p.a]++;
		userTopicCountSum[i]++;
		topicItemCount[p.a][item]++;
		topicItemCountSum[p.a]++;

		/*
		 * double proba[]=new double[2]; proba[0]=(userSCount[i][0] + gamma[0]) /
		 * (length - 1 + gamma_sum); proba[1]=(userSCount[i][1] + gamma[1]) / (length -
		 * 1 + gamma_sum);
		 * 
		 * System.out.println("lambda_0:"+proba[0]);
		 * System.out.println("lambda_1:"+proba[1]);
		 */

		return p;
	}

	/*
	 * public pair sample2(int i,int j) { pair p = new pair(); UserProfile user =
	 * user_item.get(i);
	 * 
	 * int topic = user.getZ(j);
	 * 
	 * int s = user.getS(j); int item = user.getItem(j); int length =
	 * user.items.size();
	 * 
	 * 
	 * userSCount[i][user.getS(j)]--; if(s == 0){ userAreaCount[i][topic]--;
	 * userAreaCountSum[i]--; areaItemCount[topic][item]--;
	 * areaItemCountSum[topic]--; } else{ userTopicCount[i][topic]--;
	 * userTopicCountSum[i]--; topicItemCount[topic][item]--;
	 * topicItemCountSum[topic]--; }
	 * 
	 * 
	 * 
	 * 
	 * double probability[]; // //double temp_sum=0; double proba[]=new double[2];
	 * proba[0]=(userSCount[i][0] + gamma[0]) / (length - 1 + gamma_sum);
	 * proba[1]=(userSCount[i][1] + gamma[1]) / (length - 1 + gamma_sum);
	 * 
	 * System.out.println("lambda_0:"+proba[0]);
	 * System.out.println("lambda_1:"+proba[1]);
	 * 
	 * 
	 * proba[1]+=proba[0];
	 * 
	 * double pi=Math.random()*proba[1];
	 * 
	 * for(int st=0;st<2;st++) { if(pi<proba[st]) { p.a=st; break; } }
	 * 
	 * 
	 * if(p.a==0) { probability=new double[K2];
	 * 
	 * for(int z=0;z<K2;z++) { //double first_term, second_term;
	 * 
	 * 
	 * 
	 * double first_term = (userAreaCount[i][z] + alpha_2[z]) / (userAreaCountSum[i]
	 * + alpha_2_sum);
	 * 
	 * double second_term = areaItemDistribution[z][item];
	 * 
	 * probability[z]=first_term*second_term; }
	 * 
	 * 
	 * 
	 * double temp1=0; for(int z=0;z<K2;z++) { probability[z]=probability[z]+temp1;
	 * temp1=probability[z]; }
	 * 
	 * double rand=Math.random()*temp1;
	 * 
	 * for(int z=0;z<K2;z++) { if(rand< probability[z]) { p.b=z; break; }
	 * 
	 * }
	 * 
	 * 
	 * 
	 * 
	 * } else {
	 * 
	 * probability=new double[K1]; // double first_term, second_term; for(int
	 * z=0;z<K1;z++) {
	 * 
	 * double first_term = (userTopicCount[i][z] + alpha[z]) / (userTopicCountSum[i]
	 * + alpha_sum);
	 * 
	 * double second_term = (topicItemCount[z][item] + beta[item]) /
	 * (topicItemCountSum[z] + beta_sum);;
	 * 
	 * probability[z]=first_term*second_term;
	 * 
	 * 
	 * 
	 * 
	 * }
	 * 
	 * double temp1=0; for(int z=0;z<K1;z++) { probability[z]=probability[z]+temp1;
	 * temp1=probability[z]; }
	 * 
	 * double rand=Math.random()*temp1;
	 * 
	 * for(int z=0;z<K1;z++) { if(rand< probability[z]) { p.b=z; break; }
	 * 
	 * }
	 * 
	 * 
	 * }
	 * 
	 * 
	 * 
	 * if(p.a<0||p.b<0) { System.out.println("sampling error"); }
	 * userSCount[i][p.a]++; if(p.a == 0){ userAreaCount[i][p.b]++;
	 * userAreaCountSum[i]++; areaItemCount[p.b][item]++; areaItemCountSum[p.b]++; }
	 * else{ userTopicCount[i][p.b]++; userTopicCountSum[i]++;
	 * topicItemCount[p.b][item]++; topicItemCountSum[p.b]++; }
	 * 
	 * 
	 * 
	 * 
	 * 
	 * return p; }
	 */
	public void updateParameter() {
		// userTopic
		for (int i = 0; i < U; i++) {
			for (int j = 0; j < K1; j++) {
				userTopicSum[i][j] += (userTopicCount[i][j] + alpha[j]) / (userTopicCountSum[i] + alpha_sum);

				this.topic_Count[j] += userTopicCount[i][j];
			}
		}
		userTopicNum++;

		// locTopic
		for (int i = 0; i < U; i++) {
			for (int j = 0; j < K2; j++) {
				userAreaSum[i][j] += (userAreaCount[i][j] + alpha_2[j]) / (userAreaCountSum[i] + alpha_2_sum);

				this.region_Count[j] += userAreaCount[i][j];
			}
		}
		userAreaNum++;

		// topicWord
		for (int i = 0; i < K1; i++) {
			for (int j = 0; j < V; j++) {
				topicItemSum[i][j] += (topicItemCount[i][j] + beta[j]) / (topicItemCountSum[i] + beta_sum);
			}
		}
		topicItemNum++;

		// topicCategory
		for (int i = 0; i < K2; i++) {

			for (int j = 0; j < V; j++) {
				areaItemSum[i][j] += areaItemDistribution[i][j];

			}

			muSum[i][0] += mu[i].getX();
			muSum[i][1] += mu[i].getY();
			covarianceSum[i][0] += this.covariance[i][0];
			covarianceSum[i][1] += this.covariance[i][1];

		}
		areaItemNum++;

	}

	public void output_model() {
		System.out.println("output model ...");

		// parameter
		String parameter_file = outputPath + "matrix/parameter.txt";
		OutputStreamWriter oswpf = data_storage.file_handle(parameter_file);
		output_parameter(oswpf);

		// matrix
		output_matrix(outputPath + "matrix/");

		System.out.println("output model ... done");
	}

	public void output_model(int i) {
		System.out.println("output model " + i);

		// parameter
		String parameter_file = outputPath + i + "/parameter.txt";
		OutputStreamWriter oswpf = data_storage.file_handle(parameter_file);
		output_parameter(oswpf);

		// matrix
		output_matrix(outputPath + i + "/");

		System.out.println("output model ... done" + i);
	}
	/*
	 * public void output_model_path(String base_path){
	 * System.out.println("output model ...");
	 * 
	 * // parameter String parameter_file = base_path + "parameter.txt";
	 * OutputStreamWriter oswpf = data_storage.file_handle(parameter_file);
	 * output_parameter(oswpf);
	 * 
	 * // matrix output_matrix(base_path);
	 * 
	 * System.out.println("output model ... done"); }
	 */

	public void output_matrix(String base_path) {

		try {
			// userTopic
			String userTopic_file = base_path + "userTopic.txt";
			OutputStreamWriter oswpf = data_storage.file_handle(userTopic_file);
			oswpf.write(U + " " + K1 + "\n");
			for (int i = 0; i < U; i++) {
				for (int j = 0; j < K1; j++) {
					oswpf.write(userTopicDistribution[i][j] + " ");
				}
				oswpf.write("\n");
			}
			oswpf.flush();
			oswpf.close();

			// locTopic
			String locTopic_file = base_path + "userArea.txt";
			oswpf = data_storage.file_handle(locTopic_file);
			oswpf.write(U + " " + K2 + "\n");
			for (int i = 0; i < U; i++) {
				for (int j = 0; j < K2; j++) {
					oswpf.write(userAreaDistribution[i][j] + " ");
				}
				oswpf.write("\n");
			}
			oswpf.flush();
			oswpf.close();

			// topicWord
			String topicWord_file = base_path + "topicItem.txt";
			oswpf = data_storage.file_handle(topicWord_file);
			oswpf.write(K1 + " " + V + "\n");
			for (int i = 0; i < K1; i++) {
				for (int j = 0; j < V; j++) {
					oswpf.write(topicItemDistribution[i][j] + " ");
				}
				oswpf.write("\n");
			}
			oswpf.flush();
			oswpf.close();

			// topicLoc
			String topicLoc_file = base_path + "AreaItem.txt";
			oswpf = data_storage.file_handle(topicLoc_file);
			oswpf.write(K2 + " " + V + "\n");
			for (int i = 0; i < K2; i++) {
				for (int j = 0; j < V; j++) {
					oswpf.write(areaItemDistribution[i][j] + " ");
				}
				oswpf.write("\n");
			}
			oswpf.flush();
			oswpf.close();

			// topic Popularity
			String Topic_file = base_path + "topicPopularity.txt";
			oswpf = data_storage.file_handle(Topic_file);
			oswpf.write(K1 + "\n");

			for (int j = 0; j < K1; j++) {
				oswpf.write(this.topic_Popularity[j] + " ");

			}
			oswpf.flush();
			oswpf.close();

			// topic Popularity
			String Region_file = base_path + "regionPopularity.txt";
			oswpf = data_storage.file_handle(Region_file);
			oswpf.write(K2 + "\n");

			for (int j = 0; j < K2; j++) {
				oswpf.write(this.region_Popularity[j] + " ");

			}
			oswpf.flush();
			oswpf.close();

			// mu
			String mu_file = base_path + "mu.txt";
			oswpf = data_storage.file_handle(mu_file);
			oswpf.write(K2 + "\n");
			for (int i = 0; i < K2; i++) {

				oswpf.write(mu[i].getX() + ":" + mu[i].getY() + " ");
			}
			oswpf.write("\n");
			oswpf.flush();
			oswpf.close();

			// covariance

			String co_file = base_path + "covariance.txt";
			oswpf = data_storage.file_handle(co_file);
			oswpf.write(K2 + "\n");
			for (int i = 0; i < K2; i++) {

				oswpf.write(covariance[i][0] + ":" + covariance[i][1] + " ");
			}
			oswpf.write("\n");
			oswpf.flush();
			oswpf.close();

		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public void output_parameter(OutputStreamWriter oswpf) {
		try {
			oswpf.write("U: " + U + "\n");
			oswpf.write("V: " + V + "\n");
			oswpf.write("K1: " + K1 + "\n");
			oswpf.write("K2: " + K2 + "\n");

			// Gaussian Parameters
			oswpf.write("mu:\n");
			for (int i = 0; i < K2; i++) {
				oswpf.write(this.mu[i].getX() + ":" + this.mu[i].getY() + " ");
			}
			oswpf.write("\n");

			oswpf.write("covariance:\n");
			for (int i = 0; i < K2; i++) {
				oswpf.write(this.covariance[i][0] + ":" + this.covariance[i][1] + " ");
			}
			oswpf.write("\n");

			// alpha
			oswpf.write("alpha:\n");
			for (int i = 0; i < K1; i++) {
				oswpf.write(alpha[i] + " ");
			}
			oswpf.write("\n");

			// alpha_2
			oswpf.write("alpha_2:\n");
			for (int i = 0; i < K2; i++) {
				oswpf.write(alpha_2[i] + " ");
			}
			oswpf.write("\n");

			// beta
			oswpf.write("beta:\n");
			for (int i = 0; i < V; i++) {
				oswpf.write(beta[i] + " ");
			}
			oswpf.write("\n");

			oswpf.write("ITERATIONS: " + ITERATIONS + "\n");
			oswpf.write("SAMPLE_LAG: " + SAMPLE_LAG + "\n");
			oswpf.write("BURN_IN: " + BURN_IN + "\n");
			oswpf.write("outputPath: " + outputPath + "\n");

			oswpf.flush();
			oswpf.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public void calDistribution() {
		// userTopic
		for (int i = 0; i < U; i++) {
			for (int j = 0; j < K1; j++) {
				userTopicDistribution[i][j] = userTopicSum[i][j] / userTopicNum;
			}
		}

		for (int j = 0; j < K1; j++) {
			this.topic_Popularity[j] = this.topic_Count[j] * 1.0 / userTopicNum;
		}

		for (int j = 0; j < K2; j++) {
			this.region_Popularity[j] = this.region_Count[j] * 1.0 / userAreaNum;
		}

		// locTopic
		for (int i = 0; i < U; i++) {
			for (int j = 0; j < K2; j++) {
				userAreaDistribution[i][j] = userAreaSum[i][j] / userAreaNum;

			}
		}

		// topicWord
		for (int i = 0; i < K1; i++) {
			for (int j = 0; j < V; j++) {
				topicItemDistribution[i][j] = topicItemSum[i][j] / topicItemNum;
			}
		}

		// topicCategory
		for (int i = 0; i < K2; i++) {
			for (int j = 0; j < V; j++) {
				areaItemDistribution[i][j] = areaItemSum[i][j] / areaItemNum;
			}

			this.mu[i].x = this.muSum[i][0] / areaItemNum;
			this.mu[i].y = this.muSum[i][1] / areaItemNum;

			this.covariance[i][0] = this.covarianceSum[i][0] / areaItemNum;
			this.covariance[i][1] = this.covarianceSum[i][1] / areaItemNum;
			// this.covariance[i][1][0]=this.covarianceSum[i][1][0]/areaItemNum;
			// this.covariance[i][1][1]=this.covarianceSum[i][1][1]/areaItemNum;
		}

	}

	public double GaussianProbability(Point p, int x) {
		double probability;

		// Matrix sigma=new Matrix(this.covariance[x]);

		if (this.covariance[x][0] == 0 && this.covariance[x][1] == 0) {
			return 1;
		} else if (this.covariance[x][0] == 0 || this.covariance[x][1] == 0) {
			this.covariance[x][0] = (this.covariance[x][0] + this.covariance[x][1]) / 2;
			this.covariance[x][1] = this.covariance[x][0];
		}

		double normalization = 1.0 / (2 * Math.sqrt(this.covariance[x][0]) * Math.sqrt(this.covariance[x][1]));

		// double temp[]=new double[2];

		double X = (p.getX() - this.mu[x].getX());
		double Y = (p.getY() - this.mu[x].getY());

		// double temp2[][]=new double[1][2];
		// temp2[0][0]=X;
		// temp2[0][1]=Y;

		// Matrix te=new Matrix(temp2);
		double body = (X * X) / (-2 * this.covariance[x][0]) + (Y * Y) / (-2 * this.covariance[x][1]);

		// temp[0]=X*inverse_matrix[0][0]+Y*inverse_matrix[1][0];
		// temp[1]=X*inverse_matrix[0][1]+Y*inverse_matrix[1][1];

		double main = Math.exp(body);

		probability = normalization * main;

		return probability;
	}

	public void load_data(String checkinfile) {
		usercheckinset = new HashMap<Integer, HashSet<Integer>>();
		home_location = new HashMap<Integer, Point>();
		location_map = new HashMap<Integer, Point>();
		ReadUserCheckins(checkinfile);
		ComputeHomeLocation();

		user_item = new HashMap<Integer, UserProfile>();
		for (int user : usercheckinset.keySet()) {
			UserProfile u = new UserProfile(user, home_location.get(user));
			for (int item : usercheckinset.get(user)) {
				u.addItem(item);//item是locationid
			}

			user_item.put(user, u);

		}

	}

	private void ComputeHomeLocation() {

		for (int user : usercheckinset.keySet()) {
			ArrayList<Point> li = new ArrayList<Point>();
			for (int each : usercheckinset.get(user)) {
				Point p1 = location_map.get(each);
				li.add(p1);
			}

			Point p = getHomeLocation(li);
			home_location.put(user, p);
		}

		System.out.println("Home Location Inference Finished.");
	}

	private Point getHomeLocation(ArrayList<Point> checkins) {
		Point home = new Point();
		int num = 1;

		HashMap<Double, HashMap<Double, ArrayList<Point>>> result = new HashMap<Double, HashMap<Double, ArrayList<Point>>>();
		for (Point each : checkins) {

			double x = getApproximation(each.getX(), num);
			double y = getApproximation(each.getY(), num);
			if (result.containsKey(x)) {

				if (result.get(x).containsKey(y)) {
					result.get(x).get(y).add(each);
					// int count=result.get(x).get(y)+1;
					// result.get(x).put(y, count);
				} else {
					ArrayList<Point> li = new ArrayList<Point>();
					li.add(each);
					result.get(x).put(y, li);
				}
			} else {
				HashMap<Double, ArrayList<Point>> ma = new HashMap<Double, ArrayList<Point>>();
				ArrayList<Point> li = new ArrayList<Point>();
				li.add(each);
				ma.put(y, li);
				result.put(x, ma);

			}

		}

		int max = 0;
		for (Double x : result.keySet()) {
			for (Double y : result.get(x).keySet()) {
				if (result.get(x).get(y).size() > max) {
					max = result.get(x).get(y).size();
					home.setX(x);
					home.setY(y);
				}
			}

		}

		double sum_x = 0;
		double sum_y = 0;
		if (result.containsKey(home.getX()) && result.get(home.getX()).containsKey(home.getY())) {
			for (Point each : result.get(home.getX()).get(home.getY())) {

				sum_x += each.getX();
				sum_y += each.getY();
			}
		}

		home.setX(sum_x / max);
		home.setY(sum_y / max);
		return home;

	}

	// compute distance based on latitude and longtude
	// kilometers x denotes weidu/latitude; y denotes longtude
	public double getDistance(Point a, Point b) {
		Double R = new Double(6371);
		Double dlat = (b.getX() - a.getX()) * Math.PI / 180;
		Double dlon = (b.getY() - a.getY()) * Math.PI / 180;
		Double aDouble = Math.sin(dlat / 2) * Math.sin(dlat / 2) + Math.cos(a.getX() * Math.PI / 180)
				* Math.cos(b.getX() * Math.PI / 180) * Math.sin(dlon / 2) * Math.sin(dlon / 2);
		Double cDouble = 2 * Math.atan2(Math.sqrt(aDouble), Math.sqrt(1 - aDouble));
		double d = Math.round((R * cDouble) * 1000) / 1000;
		return d;

	}

	private double getApproximation(double ori, int num) {

		BigDecimal b = new BigDecimal(ori);
		double f1 = b.setScale(num, BigDecimal.ROUND_HALF_UP).doubleValue();

		return f1;
	}

	private void ReadUserCheckins(String file) {
		BufferedReader reader;
		try {

			reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
			String line = reader.readLine();
			while (line != null) {
				String[] tokens = line.split("\t");
				int user = Integer.parseInt(tokens[0]);
				double latitude = Double.parseDouble(tokens[2]);
				double longitude = Double.parseDouble(tokens[3]);
				int lid = Integer.parseInt(tokens[4]);
				Point p = new Point(latitude, longitude, lid); 

				if (usercheckinset.containsKey(user)) {
					// usercheckins.get(user).add(p);
					usercheckinset.get(user).add(p.id);
				} else {
					// ArrayList<Point> li=new ArrayList<Point>();
					// li.add(p);
					// usercheckins.put(user,li);

					HashSet<Integer> se = new HashSet<Integer>();
					se.add(p.id);
					usercheckinset.put(user, se);
				}

				if (!location_map.containsKey(lid)) {
					location_map.put(lid, p);
				}

				line = reader.readLine();
			}

			System.out.println("Loading Checkins Finished.");
		} catch (IOException e) {
			e.printStackTrace();
		}

	}

}
